{"version":3,"file":"main.js","sources":["../node_modules/ivi/dist/client/core.js","../src/main.ts"],"sourcesContent":["export const EMPTY_ARRAY = [];\n/**\n * Globally shared data is automatically generated by clientOptimizer plugin.\n */\nconst __IVI_DATA__ = /*@__IVI_DATA__*/ [];\n// Store global variables in a local scope as const variables so that JIT\n// compiler could easily inline functions and eliminate checks in case global\n// variables are overriden.\nconst _Object = Object;\nconst _Array = Array;\nconst _isArray = _Array.isArray;\nconst _Map = Map;\nconst _Int32Array = Int32Array;\nconst _queueMicrotask = queueMicrotask;\nconst _requestAnimationFrame = requestAnimationFrame;\nconst _requestIdleCallback = requestIdleCallback;\nconst nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\nconst doc = document;\n// Template containers are used to create static templates from HTML strings\n// via `innerHTML`.\nconst HTM_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst HTM_TEMPLATE_CONTENT = HTM_TEMPLATE.content;\nconst _SVG_TEMPLATE = /**@__PURE__*/ doc.createElement(\"template\");\nconst SVG_TEMPLATE = /**@__PURE__*/ doc.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n/**@__PURE__*/ _SVG_TEMPLATE.content.appendChild(SVG_TEMPLATE);\nconst SVG_TEMPLATE_CONTENT = _SVG_TEMPLATE.content.firstChild;\n// Store Node/Element methods to avoid going through a long prototype chain and\n// avoid megamorphic call-sites when accessing DOM nodes.\n/** `Node.prototype.insertBefore` */\nconst nodeInsertBefore = nodeProto.insertBefore;\n/** `Node.prototype.removeChild`. */\nconst nodeRemoveChild = nodeProto.removeChild;\n/** `Node.prototype.cloneNode`. */\nconst nodeCloneNode = nodeProto.cloneNode;\n/** `Element.prototype.setAttribute` */\nconst elementGetAttribute = elementProto.getAttribute;\n/** `Element.prototype.setAttribute` */\nconst elementSetAttribute = elementProto.setAttribute;\n/** `Element.prototype.removeAttribute` */\nconst elementRemoveAttribute = elementProto.removeAttribute;\n/** `EventTarget.prototype.addEventListener` */\nconst elementAddEventListener = elementProto.addEventListener;\n/** `EventTarget.prototype.removeEventListener` */\nconst elementRemoveEventListener = elementProto.removeEventListener;\n/** `Object.getOwnPropertyDescriptor(o, p)` */\nconst getDescriptor = (o, p) => _Object.getOwnPropertyDescriptor(o, p);\n/** `get Node.prototype.firstChild` */\nconst nodeGetFirstChild = /*@__PURE__*/ getDescriptor(nodeProto, \"firstChild\").get;\n/** `get Node.prototype.lastChild` */\nconst nodeGetLastChild = /*@__PURE__*/ getDescriptor(nodeProto, \"lastChild\").get;\n/** `get Node.prototype.nextSibling` */\nconst nodeGetNextSibling = /*@__PURE__*/ getDescriptor(nodeProto, \"nextSibling\").get;\n/** `get Node.prototype.previousSibling` */\nconst nodeGetPreviousSibling = /*@__PURE__*/ getDescriptor(nodeProto, \"previousSibling\").get;\n/** `set Node.prototype.textContent` */\nconst nodeSetTextContent = /*@__PURE__*/ getDescriptor(nodeProto, \"textContent\").set;\n/** `get Node.prototype.nodeType` */\nconst nodeGetNodeType = /*@__PURE__*/ getDescriptor(nodeProto, \"nodeType\").get;\n/** `set Element.prototype.innerHTML` */\nconst elementSetInnerHTML = /*@__PURE__*/ getDescriptor(elementProto, \"innerHTML\").set;\n/** `set Element.prototype.className` */\nconst elementSetClassName = /*@__PURE__*/ getDescriptor(elementProto, \"className\").set;\n/** `get HTMLElement.prototype.style`. */\nconst htmlElementGetStyle = /*@__PURE__*/ getDescriptor(HTMLElement.prototype, \"style\").get;\n/** `get SVGElement.prototype.style` */\nconst svgElementGetStyle = /*@__PURE__*/ getDescriptor(SVGElement.prototype, \"style\").get;\n// When object is sealed and stored in a const variable, JIT compiler can\n// eliminate object map(shape) checks when accessing its properties.\n/**\n * Global Render Context.\n */\nexport const RENDER_CONTEXT = _Object.seal({\n    p: null,\n    n: null,\n    si: 0,\n    e: [],\n});\n/**\n * Creates a Stateful Node instance.\n *\n * @param v VNode.\n * @returns {@link SNode} instance.\n */\nexport const createSNode = (f, v, c, p, s1) => ({ f, v, c, p, s1 });\nexport const _flushDOMEffects = () => {\n    const e = RENDER_CONTEXT.e;\n    if (e.length > 0) {\n        RENDER_CONTEXT.e = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nconst _updateTemplateProperties = (currentElement, opCodes, data, state, prevProps, nextProps, svg) => {\n    let style;\n    for (let i = 0; i < opCodes.length; i++) {\n        const op = opCodes[i];\n        const type = op & 7 /* PropOpCode.TypeMask */;\n        const dataIndex = op >> 9 /* PropOpCode.DataShift */;\n        if (type === 0 /* PropOpCode.SetNode */) {\n            currentElement = state[dataIndex];\n            style = void 0;\n        }\n        else {\n            const propsIndex = (op >> 3 /* PropOpCode.InputShift */) & 63 /* PropOpCode.Mask6 */;\n            const next = nextProps[propsIndex];\n            if (type === 4 /* PropOpCode.DiffDOMProperty */) {\n                const key = data[dataIndex];\n                if (prevProps === null) {\n                    if (next !== void 0) {\n                        currentElement[key] = next;\n                    }\n                }\n                else if (currentElement[key] !== next) {\n                    currentElement[key] = next;\n                }\n            }\n            else {\n                let prev;\n                if (prevProps !== null) {\n                    prev = prevProps[propsIndex];\n                }\n                if (prev !== next) {\n                    if (type === 1 /* PropOpCode.Common */) {\n                        if (dataIndex === 0 /* CommonPropType.ClassName */) {\n                            if (next !== \"\" && next != null && next !== false) {\n                                elementSetClassName.call(currentElement, next);\n                            }\n                            else if (prev !== \"\" && prev != null && prev !== false) {\n                                elementSetClassName.call(currentElement, \"\");\n                            }\n                        }\n                        else if (dataIndex === 1 /* CommonPropType.TextContent */) {\n                            if (next !== \"\" && next != null && next !== false) {\n                                if (prev == null || prev === \"\" || prev === false) {\n                                    nodeSetTextContent.call(currentElement, next);\n                                }\n                                else {\n                                    nodeGetFirstChild.call(currentElement).nodeValue = next;\n                                }\n                            }\n                            else if (prev != null && prev !== \"\" && prev !== false) {\n                                nodeSetTextContent.call(currentElement, \"\");\n                            }\n                        }\n                        else { // CommonPropType.InnerHTML\n                            if (next !== \"\" && next != null && next !== false) {\n                                elementSetInnerHTML.call(currentElement, next);\n                            }\n                            else if (prev !== \"\" && prev != null && prev !== false) {\n                                nodeSetTextContent.call(currentElement, \"\");\n                            }\n                        }\n                    }\n                    else if (type === 7 /* PropOpCode.Directive */) {\n                        next(currentElement);\n                    }\n                    else {\n                        const key = data[dataIndex];\n                        if (type === 2 /* PropOpCode.Attribute */) {\n                            if (next !== false && next != null) {\n                                elementSetAttribute.call(currentElement, key, next);\n                            }\n                            else if (prev !== false && prev != null) {\n                                elementRemoveAttribute.call(currentElement, key);\n                            }\n                        }\n                        else if (type === 3 /* PropOpCode.Property */) {\n                            currentElement[key] = next;\n                        }\n                        else if (type === 5 /* PropOpCode.Style */) {\n                            if (next !== false && next != null) {\n                                if (style === void 0) {\n                                    style = (svg === false)\n                                        ? htmlElementGetStyle.call(currentElement)\n                                        : svgElementGetStyle.call(currentElement);\n                                }\n                                style.setProperty(key, next);\n                            }\n                            else if (prev !== false && prev != null) {\n                                if (style === void 0) {\n                                    style = (svg === false)\n                                        ? htmlElementGetStyle.call(currentElement)\n                                        : svgElementGetStyle.call(currentElement);\n                                }\n                                style.removeProperty(key);\n                            }\n                        }\n                        else { // PropOpCode.Event\n                            if (prev != null && prev !== false) {\n                                elementRemoveEventListener.call(currentElement, key, prev);\n                            }\n                            if (next != null && next !== false) {\n                                elementAddEventListener.call(currentElement, key, next);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\nconst _assignTemplateSlots = (currentNode, opCodes, offset, endOffset, state) => {\n    const ctx = RENDER_CONTEXT;\n    while (true) {\n        const op = opCodes[offset++];\n        if (op & 1 /* StateOpCode.Save */) {\n            state[++ctx.si] = currentNode;\n        }\n        if (op & 2 /* StateOpCode.EnterOrRemove */) {\n            const enterOffset = op >> 3 /* StateOpCode.OffsetShift */;\n            // Enter offset is used to disambiguate between enter and remove\n            // operations. Remove operations will always have a 0 enterOffset.\n            if (enterOffset) { // Enter\n                _assignTemplateSlots(nodeGetFirstChild.call(currentNode), opCodes, offset, offset += enterOffset, state);\n            }\n            else { // Remove\n                // Remove operation implies that current node is always a comment node\n                // followed by a text node.\n                const commentNode = currentNode;\n                state[++ctx.si] = currentNode = nodeGetNextSibling.call(currentNode);\n                commentNode.remove();\n            }\n        }\n        if (offset === endOffset) {\n            return;\n        }\n        currentNode = nodeGetNextSibling.call(currentNode);\n    }\n};\nconst _mountList = (parentState, flags, children, vNode) => {\n    let i = children.length;\n    const sChildren = _Array(i);\n    const sNode = createSNode(flags, vNode, sChildren, parentState, null);\n    while (i > 0) {\n        sChildren[--i] = _mount(sNode, children[i]);\n    }\n    return sNode;\n};\nconst _updateArray = (parentSNode, sNode, next, updateFlags) => {\n    if (!_isArray(next)) {\n        _unmount(sNode, true);\n        return _mount(parentSNode, next);\n    }\n    const prevSChildren = sNode.c;\n    let nextSChildren = prevSChildren;\n    let prevLength = prevSChildren.length;\n    let nextLength = next.length;\n    if (nextLength !== prevLength) {\n        sNode.c = nextSChildren = _Array(nextLength);\n        while (prevLength > nextLength) {\n            const sChild = prevSChildren[--prevLength];\n            if (sChild !== null) {\n                _unmount(sChild, true);\n            }\n        }\n        while (nextLength > prevLength) {\n            nextSChildren[--nextLength] = _mount(sNode, next[nextLength]);\n        }\n    }\n    while (nextLength > 0) {\n        nextSChildren[--nextLength] = _update(sNode, prevSChildren[nextLength], next[nextLength], updateFlags);\n    }\n    return sNode;\n};\n/**\n * Updates a Stateful Node with a new Stateless Node.\n *\n * @param parentSNode Parent Stateul Node.\n * @param sNode Stateful Node to update.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n * @returns Stateful Node.\n */\nconst _update = (parentSNode, sNode, next, updateFlags) => {\n    if (sNode === null) {\n        return _mount(parentSNode, next);\n    }\n    if (next === false || next == null || next === \"\") {\n        _unmount(sNode, true);\n        return null;\n    }\n    // polymorphic call-site\n    const children = sNode.c;\n    const prev = sNode.v;\n    const state = sNode.s1;\n    const flags = sNode.f;\n    const type = flags & 127 /* Flags.TypeMask */;\n    sNode.f = type;\n    // Reassign to reduce memory consumption even if next value is strictly\n    // equal to the prev value.\n    sNode.v = next;\n    // Text and Array should be checked before Component, Template and List\n    // because their stateless nodes are represented with basic string and array\n    // types.\n    if (type === 16 /* Flags.Text */) {\n        const ctx = RENDER_CONTEXT;\n        if (typeof next !== \"object\") {\n            if (prev !== next) {\n                state.nodeValue = next;\n            }\n            if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n                nodeInsertBefore.call(ctx.p, state, ctx.n);\n            }\n            ctx.n = state;\n            return sNode;\n        }\n        nodeRemoveChild.call(ctx.p, state);\n        return _mount(parentSNode, next);\n    }\n    if (prev === next) {\n        _dirtyCheck(sNode, updateFlags);\n        return sNode;\n    }\n    // Dirty flags should be cleared after dirty checking.\n    sNode.f = type;\n    if (type === 8 /* Flags.Array */) {\n        return _updateArray(parentSNode, sNode, next, updateFlags);\n    }\n    const descriptor = next.d;\n    const nextProps = next.p;\n    const prevProps = prev.p;\n    if (prev.d !== descriptor) {\n        _unmount(sNode, true);\n        return _mount(parentSNode, next);\n    }\n    if (type === 2 /* Flags.Component */) {\n        if (((flags | updateFlags) & (128 /* Flags.Dirty */ | 512 /* Flags.ForceUpdate */)) ||\n            (descriptor.p2 === void 0) ||\n            (descriptor.p2(prevProps, nextProps) !== true)) {\n            sNode.c = _update(sNode, children, state(nextProps), updateFlags);\n        }\n        else if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else if (type === 1 /* Flags.Template */) {\n        const ctx = RENDER_CONTEXT;\n        const parentElement = ctx.p;\n        const tplData = descriptor.p1;\n        const flags = tplData.f;\n        const data = tplData.d;\n        const propsOpCodes = tplData.p;\n        const childOpCodes = tplData.c;\n        const rootDOMNode = state[0];\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            updateFlags ^= 1024 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(parentElement, rootDOMNode, ctx.n);\n        }\n        _updateTemplateProperties(rootDOMNode, propsOpCodes, data, state, prevProps, nextProps, !!(flags & 4096 /* TemplateFlags.Svg */));\n        if (children !== null) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            let childrenIndex = 0;\n            for (let i = 0; i < childOpCodes.length; i++) {\n                const childOpCode = childOpCodes[i];\n                const type = childOpCode & 3 /* ChildOpCode.Type */;\n                const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    children[childrenIndex] =\n                        _update(sNode, children[childrenIndex++], nextProps[value], updateFlags);\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else if (type === 4 /* Flags.List */) {\n        _updateList(sNode, prevProps, nextProps, updateFlags);\n    }\n    else { // Context\n        if (prevProps.v !== nextProps.v) {\n            updateFlags |= 512 /* Flags.ForceUpdate */;\n        }\n        sNode.c = _update(sNode, children, nextProps.c, updateFlags);\n    }\n    return sNode;\n};\n/**\n * Mounts Stateless Node.\n *\n * @param parentSNode Parent Stateful Node.\n * @param v Stateless Node.\n * @returns Mounted Stateful Node.\n */\nconst _mount = (parentSNode, v) => {\n    if (v !== false && v != null) {\n        if (typeof v === \"object\") {\n            if (_isArray(v)) {\n                return _mountList(parentSNode, 8 /* Flags.Array */, v, v);\n            }\n            else {\n                const descriptor = v.d;\n                const props = v.p;\n                const descriptorP1 = descriptor.p1;\n                const type = descriptor.f & (1 /* Flags.Template */ | 2 /* Flags.Component */ | 4 /* Flags.List */);\n                if (type === 1 /* Flags.Template */) {\n                    const ctx = RENDER_CONTEXT;\n                    const parentDOMElement = ctx.p;\n                    const nextDOMNode = ctx.n;\n                    const tplData = descriptorP1;\n                    const data = tplData.d;\n                    const propsOpCodes = tplData.p;\n                    const stateOpCodes = tplData.s;\n                    const childOpCodes = tplData.c;\n                    const flags = tplData.f;\n                    const rootDOMNode = descriptor.p2();\n                    const state = _Array(flags & 63 /* TemplateFlags.Mask6 */);\n                    state[0] = rootDOMNode;\n                    if (stateOpCodes.length > 0) {\n                        ctx.si = 0;\n                        _assignTemplateSlots(nodeGetFirstChild.call(rootDOMNode), stateOpCodes, 0, stateOpCodes.length, state);\n                    }\n                    _updateTemplateProperties(rootDOMNode, propsOpCodes, data, state, null, props, !!(flags & 4096 /* TemplateFlags.Svg */));\n                    const sNode = createSNode(1 /* Flags.Template */, v, null, parentSNode, state);\n                    if (childOpCodes.length > 0) {\n                        const children = _Array((flags >> 6 /* TemplateFlags.ChildrenSizeShift */) & 63 /* TemplateFlags.Mask6 */);\n                        sNode.c = children;\n                        ctx.p = rootDOMNode;\n                        ctx.n = null;\n                        let childrenIndex = 0;\n                        for (let i = 0; i < childOpCodes.length; i++) {\n                            const childOpCode = childOpCodes[i];\n                            const type = childOpCode & 3 /* ChildOpCode.Type */;\n                            const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                            if (type === 0 /* ChildOpCode.Child */) {\n                                children[childrenIndex++] = _mount(sNode, props[value]);\n                            }\n                            else if (type === 1 /* ChildOpCode.SetNext */) {\n                                ctx.n = state[value];\n                            }\n                            else { // ChildOpCode.SetParent\n                                ctx.p = state[value];\n                                ctx.n = null;\n                            }\n                        }\n                        ctx.p = parentDOMElement;\n                    }\n                    ctx.n = rootDOMNode;\n                    nodeInsertBefore.call(parentDOMElement, rootDOMNode, nextDOMNode);\n                    return sNode;\n                }\n                else if (type === 2 /* Flags.Component */) {\n                    const sNode = {\n                        f: 2 /* Flags.Component */,\n                        v: v,\n                        c: null,\n                        p: parentSNode,\n                        s1: null,\n                        s2: null,\n                    };\n                    const renderFn = descriptorP1(sNode);\n                    sNode.c = _mount(sNode, renderFn(props));\n                    sNode.s1 = renderFn;\n                    return sNode;\n                }\n                else if (type === 4 /* Flags.List */) {\n                    return _mountList(parentSNode, 4 /* Flags.List */, props.v, v);\n                }\n                // Context\n                const sNode = createSNode(64 /* Flags.Context */, v, null, parentSNode, null);\n                sNode.c = _mount(sNode, props.c);\n                return sNode;\n            }\n        }\n        else if (v !== \"\") { // text\n            const ctx = RENDER_CONTEXT;\n            const next = ctx.n;\n            const e = doc.createTextNode(v);\n            ctx.n = e;\n            nodeInsertBefore.call(ctx.p, e, next);\n            return createSNode(16 /* Flags.Text */, v, null, parentSNode, e);\n        }\n    }\n    return null;\n};\n/**\n * Performs a Dirty Checking in a Stateful Node Subtree.\n *\n * @param sNode Stateful Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _dirtyCheck = (sNode, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    // polymorphic call-site\n    const state = sNode.s1;\n    const v = sNode.v;\n    const children = sNode.c;\n    const flags = sNode.f;\n    const type = flags & 127 /* Flags.TypeMask */;\n    sNode.f = type;\n    if (type === 1 /* Flags.Template */) {\n        const rootDOMNode = state[0];\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            updateFlags ^= 1024 /* Flags.DisplaceNode */;\n            nodeInsertBefore.call(ctx.p, rootDOMNode, ctx.n);\n        }\n        if (flags & 256 /* Flags.DirtySubtree */) {\n            ctx.p = rootDOMNode;\n            ctx.n = null;\n            const parentDOMElement = ctx.p;\n            const childOpCodes = v.d.p1.c;\n            let childrenIndex = 0;\n            for (let i = 0; i < childOpCodes.length; i++) {\n                const op = childOpCodes[i];\n                const type = op & 3 /* ChildOpCode.Type */;\n                const value = op >> 2 /* ChildOpCode.ValueShift */;\n                if (type === 0 /* ChildOpCode.Child */) {\n                    const sChild = children[childrenIndex++];\n                    if (sChild !== null) {\n                        _dirtyCheck(sChild, updateFlags);\n                    }\n                }\n                else if (type === 1 /* ChildOpCode.SetNext */) {\n                    ctx.n = state[value];\n                }\n                else { // ChildOpCode.SetParent\n                    ctx.p = state[value];\n                    ctx.n = null;\n                }\n            }\n            ctx.p = parentDOMElement;\n        }\n        ctx.n = rootDOMNode;\n    }\n    else if (type === 16 /* Flags.Text */) {\n        if (updateFlags & 1024 /* Flags.DisplaceNode */) {\n            nodeInsertBefore.call(ctx.p, state, ctx.n);\n        }\n        ctx.n = state;\n    }\n    else if (type === 2 /* Flags.Component */) {\n        if ((flags | updateFlags) & (128 /* Flags.Dirty */ | 512 /* Flags.ForceUpdate */)) {\n            sNode.c = _update(sNode, children, state(v.p), updateFlags);\n        }\n        else if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else if (type === 64 /* Flags.Context */) {\n        if (children !== null) {\n            _dirtyCheck(children, updateFlags);\n        }\n    }\n    else { // Array || List\n        let i = children.length;\n        while (--i >= 0) {\n            const sChild = children[i];\n            if (sChild !== null) {\n                _dirtyCheck(sChild, updateFlags);\n            }\n        }\n    }\n};\n/**\n * Unmounts Stateful Node.\n *\n * @param sNode Stateful Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nconst _unmount = (sNode, detach) => {\n    const flags = sNode.f; // polymorphic call-site\n    const sChildren = sNode.c;\n    if (detach === true && (flags & (1 /* Flags.Template */ | 16 /* Flags.Text */))) {\n        detach = false;\n        nodeRemoveChild.call(RENDER_CONTEXT.p, (flags & 1 /* Flags.Template */)\n            ? sNode.s1[0]\n            : sNode.s1);\n    }\n    if (flags & 2 /* Flags.Component */) {\n        const unmountHooks = sNode.s2;\n        if (unmountHooks !== null) {\n            if (typeof unmountHooks === \"function\") {\n                unmountHooks();\n            }\n            else {\n                for (let i = 0; i < unmountHooks.length; i++) {\n                    unmountHooks[i]();\n                }\n            }\n        }\n    }\n    if (sChildren !== null) {\n        if (_isArray(sChildren)) {\n            for (let i = 0; i < sChildren.length; i++) {\n                const sChild = sChildren[i];\n                if (sChild !== null) {\n                    _unmount(sChild, detach);\n                }\n            }\n        }\n        else {\n            _unmount(sChildren, detach);\n        }\n    }\n};\n/**\n * Update children list with track by key algorithm.\n *\n * High-level overview of the algorithm that is implemented in this function:\n *\n * This algorithm finds a minimum number of DOM operations. It works in\n * several steps:\n *\n * 1. Common prefix and suffix optimization.\n *\n * Look for nodes with identical keys by simultaneously iterating through nodes\n * in the old children list `A` and new children list `B` from both sides.\n *\n *     A: -> [a b c d] <-\n *     B: -> [a b d] <-\n *\n * Skip nodes \"a\" and \"b\" at the start, and node \"d\" at the end.\n *\n *     A: -> [c] <-\n *     B: -> [] <-\n *\n * 2. Zero length optimizations.\n *\n * Check if the size of one of the list is equal to zero. When length of the\n * old children list is zero, insert remaining nodes from the new list. When\n * length of the new children list is zero, remove remaining nodes from the old\n * list.\n *\n *     A: -> [a b c g] <-\n *     B: -> [a g] <-\n *\n * Skip nodes \"a\" and \"g\" (prefix and suffix optimization).\n *\n *     A: [b c]\n *     B: []\n *\n * Remove nodes \"b\" and \"c\".\n *\n * 3. Index and unmount removed nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *\n * Create array `P` (`sources`) with the length of the new children list and\n * fills it with `NewNodeMark` values. This mark indicates that node at this\n * position should be mounted. Later we will assign node positions in the old\n * children list to this array.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [. . . . .] // . == -1\n *     I: {\n *       c: 0, // B[0] == c\n *       b: 1, // B[1] == b\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 0\n *\n * Create reverse index `I` that maps keys to node positions in the new\n * children list.\n *\n *     A: [b c d e f]\n *         ^\n *     B: [c b h f e]\n *     P: [. 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1, <-\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1\n *\n * Assign original positions of the nodes from the old children list to the\n * array `P`.\n *\n * Iterate through nodes in the old children list and gets their new positions\n * from the index `I`. Assign old node position to the array `P`. When index\n * `I` doesn't have a key for the old node, it means that it should be\n * unmounted.\n *\n * When we assigning positions to the array `P`, we also store position of the\n * last seen node in the new children list `pos`, if the last seen position is\n * greater than the current position of the node at the new list, then we are\n * switching `rearrangeNodes` flag to `true` (`pos === RearrangeNodes`).\n *\n *     A: [b c d e f]\n *           ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0, <-\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     last = 1 // last > 0; rearrangeNodes = true\n *\n * The last position `1` is greater than the current position of the node at the\n * new list `0`, switch `rearrangeNodes` flag to `true`.\n *\n *     A: [b c d e f]\n *             ^\n *     B: [c b h f e]\n *     P: [1 0 . . .] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Node with key \"d\" doesn't exist in the index `I`, unmounts node `d`.\n *\n *     A: [b c d e f]\n *               ^\n *     B: [c b h f e]\n *     P: [1 0 . . 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3,\n *       e: 4, <-\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `3` for `e` node.\n *\n *     A: [b c d e f]\n *                 ^\n *     B: [c b h f e]\n *     P: [1 0 . 4 3] // . == -1\n *     I: {\n *       c: 0,\n *       b: 1,\n *       h: 2,\n *       f: 3, <-\n *       e: 4,\n *     }\n *     rearrangeNodes = true\n *\n * Assign position `4` for 'f' node.\n *\n * 4. Find minimum number of moves when `rearrangeNodes` flag is on and mount\n *    new nodes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *     P: [1 * . 4 *] // . == -1  * == -2\n *\n * When `rearrangeNodes` is on, mark all nodes in the array `P` that belong to\n * the [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence)\n * and move all nodes that doesn't belong to this subsequence.\n *\n * Iterate over the new children list and the `P` array simultaneously. When\n * value from `P` array is equal to `NewNodeMark`, mount a new node. When it\n * isn't equal to `LisMark`, move it to a new position.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *                 ^  // new_pos == 4\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *                 ^\n *\n * Node \"e\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *               ^    // new_pos == 3\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *               ^\n *\n * Node \"f\" has `4` value in the array `P`, move it before the next node \"e\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *             ^      // new_pos == 2\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *             ^\n *\n * Node \"h\" has `NewNodeMark` value in the array `P`, mount new node \"h\".\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *           ^        // new_pos == 1\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *           ^\n *\n * Node \"b\" has `LisMark` value in the array `P`, nothing changes.\n *\n *     A: [b c d e f]\n *     B: [c b h f e]\n *         ^          // new_pos == 0\n *     P: [1 * . 4 *] // . == NewNodeMark  * == LisMark\n *\n * Node \"c\" has `1` value in the array `P`, move it before the next node \"b\".\n *\n * When `rearrangeNodes` flag is off, skip LIS algorithm and mount nodes that\n * have `NewNodeMark` value in the array `P`.\n *\n * NOTE: There are many variations of this algorithm that are used by many UI\n * libraries and many implementations are still using an old optimization\n * technique that were removed several years ago from this implementation. This\n * optimization were used to improve performance of simple moves/swaps. E.g.\n *\n *     A: -> [a b c] <-\n *     B: -> [c b a] <-\n *\n * Move \"a\" and \"c\" nodes to the other edge.\n *\n *     A: -> [b] <-\n *     B: -> [b] <-\n *\n * Skip node \"b\".\n *\n * This optimization were removed because it breaks invariant that insert and\n * remove operations shouldn't trigger a move operation. E.g.\n *\n *     A: -> [a b]\n *     B:    [c a] <-\n *\n * Move node \"a\" to the end.\n *\n *     A: [b]\n *     B: [c a]\n *\n * Remove node \"b\" and insert node \"c\".\n *\n * In this use case, this optimization performs one unnecessary operation.\n * Instead of removing node \"b\" and inserting node \"c\", it also moves node \"a\".\n *\n * @param sNode {@link SList} node.\n * @param a Previous {@link ListProps}.\n * @param b Next {@link ListProps}.\n * @param updateFlags Update flags.\n * @noinline\n * @__NOINLINE__\n */\nconst _updateList = (sNode, a, b, updateFlags) => {\n    const aKeys = a.k;\n    const bKeys = b.k;\n    const bVNodes = b.v;\n    let bLength = bKeys.length;\n    let aLength = aKeys.length;\n    const result = _Array(bLength);\n    if (bLength === 0) { // New children list is empty.\n        if (aLength > 0) { // Unmount nodes from the old children list.\n            _unmount(sNode, true);\n        }\n    }\n    else if (aLength === 0) { // Old children list is empty.\n        while (bLength > 0) { // Mount nodes from the new children list.\n            result[--bLength] = _mount(sNode, bVNodes[bLength]);\n        }\n    }\n    else {\n        const sChildren = sNode.c;\n        let aEnd = aLength - 1;\n        let bEnd = bLength - 1;\n        let start = 0;\n        // Step 1\n        outer: while (true) {\n            // Update nodes with the same key at the end.\n            while (aKeys[aEnd] === bKeys[bEnd]) {\n                result[bEnd] = _update(sNode, sChildren[aEnd--], bVNodes[bEnd], updateFlags);\n                if (start > --bEnd || start > aEnd) {\n                    break outer;\n                }\n            }\n            // Update nodes with the same key at the beginning.\n            while (aKeys[start] === bKeys[start] && ++start <= aEnd && start <= bEnd) {\n                // delayed update (all updates should be performed from right-to-left).\n            }\n            break;\n        }\n        // Step 2\n        if (start > aEnd) {\n            // All nodes from `a` are updated, insert the rest from `b`.\n            while (bEnd >= start) {\n                result[bEnd] = _mount(sNode, bVNodes[bEnd--]);\n            }\n        }\n        else if (start > bEnd) {\n            // All nodes from `b` are updated, remove the rest from `a`.\n            bLength = start;\n            do {\n                const sChild = sChildren[bLength++];\n                if (sChild !== null) {\n                    _unmount(sChild, true);\n                }\n            } while (bLength <= aEnd);\n        }\n        else { // Step 3\n            let bLength = bEnd - start + 1;\n            const sources = new _Int32Array(bLength); // Maps positions in the new children list to positions in the old list.\n            const keyIndex = new _Map(); // Maps keys to their positions in the new children list.\n            for (let i = 0; i < bLength; i++) {\n                // `NewNodeMark` value indicates that node doesn't exist in the old children list.\n                sources[i] = -1 /* MagicValues.NewNodeMark */;\n                const j = start + i;\n                keyIndex.set(bKeys[j], j);\n            }\n            // When `nodePosition === RearrangeNodes`, it means that one of the nodes is in the wrong position and we should\n            // rearrange nodes with LIS-based algorithm `markLIS()`.\n            let nodePosition = 0;\n            for (let i = start; i <= aEnd; i++) {\n                const sChild = sChildren[i];\n                const nextPosition = keyIndex.get(aKeys[i]);\n                if (nextPosition !== void 0) {\n                    nodePosition = (nodePosition < nextPosition)\n                        ? nextPosition\n                        : 1073741823 /* MagicValues.RearrangeNodes */;\n                    sources[nextPosition - start] = i;\n                    result[nextPosition] = sChild;\n                }\n                else if (sChild !== null) {\n                    _unmount(sChild, true);\n                }\n            }\n            // Step 4\n            // Mark LIS nodes only when this node weren't moved `moveNode === false` and we've detected that one of the\n            // children nodes were moved `pos === MagicValues.MovedChildren`.\n            if (!(updateFlags & 1024 /* Flags.DisplaceNode */) && nodePosition === 1073741823 /* MagicValues.RearrangeNodes */) {\n                markLIS(sources);\n            }\n            while (bLength-- > 0) {\n                bEnd = bLength + start;\n                const node = bVNodes[bEnd];\n                const lisValue = sources[bLength];\n                result[bEnd] = (lisValue === -1)\n                    ? _mount(sNode, node)\n                    : _update(sNode, result[bEnd], node, updateFlags |\n                        ((nodePosition === 1073741823 /* MagicValues.RearrangeNodes */ && lisValue !== -2 /* MagicValues.LISMark */)\n                            ? 1024 /* Flags.DisplaceNode */\n                            : 0));\n            }\n        }\n        // Delayed update for nodes from Step 1 (prefix only). Reconciliation algorithm always updates nodes from right to\n        // left.\n        while (start > 0) {\n            result[--start] = _update(sNode, sChildren[start], bVNodes[start], updateFlags);\n        }\n    }\n    sNode.c = result;\n};\n/**\n * Modified Longest Increased Subsequence algorithm.\n *\n * Mutates input array `a` and replaces all values that are part of LIS with -2 value.\n *\n * Constraints:\n * - Doesn't work with negative numbers. -1 values are ignored.\n * - Input array `a` should contain at least one value that is greater than -1.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @example\n *\n *     const A = Int32Array.from([-1, 0, 2, 1]);\n *     markLIS(A);\n *     // A => [-1, -2, 2, -2]\n *\n * @param a Array of numbers.\n * @noinline\n * @__NOINLINE__\n */\nconst markLIS = (a) => {\n    const length = a.length;\n    const parent = new _Int32Array(length);\n    const index = new _Int32Array(length);\n    let indexLength = 0;\n    let i = 0;\n    let j;\n    let k;\n    let lo;\n    let hi;\n    // Skip -1 values at the start of the input array `a`.\n    for (; a[i] === -1 /* MagicValues.NewNodeMark */; i++) { /**/ }\n    index[0] = i++;\n    for (; i < length; i++) {\n        k = a[i];\n        if (k !== -1 /* MagicValues.NewNodeMark */) { // Ignore -1 values.\n            j = index[indexLength];\n            if (a[j] < k) {\n                parent[i] = j;\n                index[++indexLength] = i;\n            }\n            else {\n                lo = 0;\n                hi = indexLength;\n                while (lo < hi) {\n                    j = (lo + hi) >> 1;\n                    if (a[index[j]] < k) {\n                        lo = j + 1;\n                    }\n                    else {\n                        hi = j;\n                    }\n                }\n                if (k < a[index[lo]]) {\n                    if (lo > 0) {\n                        parent[i] = index[lo - 1];\n                    }\n                    index[lo] = i;\n                }\n            }\n        }\n    }\n    ;\n    // Mutate input array `a` and assign -2 value to all nodes that are part of LIS.\n    j = index[indexLength];\n    while (indexLength-- >= 0) {\n        a[j] = -2 /* MagicValues.LISMark */;\n        j = parent[j];\n    }\n};\n/**\n * Creates a HTML Template cloning factory.\n */\nexport const _h = (t) => (() => {\n    if (typeof t === \"string\") {\n        HTM_TEMPLATE.innerHTML = t;\n        t = HTM_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a HTML Template factory.\n */\nexport const _hN = (t) => (() => (HTM_TEMPLATE.innerHTML = t,\n    HTM_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a HTML Element factory.\n */\nexport const _hE = (t) => (() => doc.createElement(t));\n/**\n * Creates a SVG Template cloning factory.\n */\nexport const _s = (t) => (() => {\n    if (typeof t === \"string\") {\n        SVG_TEMPLATE.innerHTML = t;\n        t = SVG_TEMPLATE_CONTENT.firstChild;\n    }\n    return nodeCloneNode.call(t, true);\n});\n/**\n * Creates a SVG Template factory.\n */\nexport const _sN = (t) => (() => (SVG_TEMPLATE.innerHTML = t,\n    SVG_TEMPLATE_CONTENT.firstChild));\n/**\n * Creates a SVG Element factory.\n */\nexport const _sE = (t) => (() => doc.createElementNS(\"http://www.w3.org/2000/svg\", t));\n/**\n * Creates a template descriptor with globally shared data.\n */\nexport const _T = (p2, f, p, c, s) => ({\n    f: 1 /* Flags.Template */,\n    p1: { f, p, c, s, d: __IVI_DATA__ },\n    p2,\n});\n/**\n * Creates a template descriptor.\n */\nexport const _Td = (p2, f, p, c, s, d) => ({\n    f: 1 /* Flags.Template */,\n    p1: { f, p, c, s, d },\n    p2,\n});\nexport const _t = (d, p) => ({ d, p });\n/**\n * Creates a factory that produces component nodes.\n *\n * @typeparam P Property type.\n * @param factory Function that produces stateful render functions.\n * @param areEqyal Function that checks `props` for equality.\n * @returns Factory that produces component nodes.\n */\nexport const component = (p1, p2) => {\n    const d = { f: 2 /* Flags.Component */, p1, p2 };\n    return (p) => ({ d, p });\n};\n/**\n * Gets current component props.\n *\n * @typeparam P Property type.\n * @param component Component node.\n * @returns Current component props.\n */\nexport const getProps = (component) => (component.v.p);\n/**\n * Adds an unmount hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       useUnmount(c, () => { console.log(\"unmounted\"); });\n *\n *       return () => null;\n *     });\n *\n * @param component Component instance.\n * @param hook Unmount hook.\n */\nexport const useUnmount = (component, hook) => {\n    const hooks = component.s2;\n    component.s2 = (hooks === null)\n        ? hook\n        : (typeof hooks === \"function\")\n            ? [hooks, hook]\n            : (hooks.push(hook), hooks);\n};\n/**\n * Creates a side effect hook.\n *\n * @example\n *\n *     const Example = component((c) => {\n *       const [count, setCount] = useState(c, 0);\n *       const timer = useEffect(c, ({ interval }) => {\n *         const tid = setInterval(() => { setCount(count() + 1); }, interval);\n *         return () => { clearInterval(tid); };\n *       }, shallowEq);\n *\n *       return (interval) => (\n *         timer({ interval }),\n *\n *         htm`<span>${count()}</span>`\n *       );\n *     });\n *\n * @typeparam T Hook props type.\n * @param component Component instance.\n * @param hook Side effect function.\n * @param areEqual Function that checks if input value hasn't changed.\n * @returns Side effect hook.\n */\nexport const useEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            RENDER_CONTEXT.e.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\nlet _layoutEffects = [];\nlet _idleEffects = [];\nconst _flushLayoutEffects = () => {\n    while (_layoutEffects.length > 0) {\n        const e = _layoutEffects;\n        _layoutEffects = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nconst _flushIdleEffects = () => {\n    while (_idleEffects.length > 0) {\n        const e = _idleEffects;\n        _idleEffects = [];\n        for (let i = 0; i < e.length; i++) {\n            e[i]();\n        }\n    }\n};\nexport const useLayoutEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            const queue = _layoutEffects;\n            if (queue.length === 0) {\n                _requestAnimationFrame(_flushLayoutEffects);\n            }\n            queue.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\nexport const useIdleEffect = (component, hook, areEqual) => {\n    // var usage is intentional, see `docs/internals/perf.md` for an explanation.\n    var reset;\n    var prev;\n    var pending;\n    return (next) => {\n        if (pending !== true && (areEqual === void 0 ||\n            prev === void 0 ||\n            areEqual(prev, next) === false)) {\n            if (pending === void 0) {\n                useUnmount(component, () => {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                });\n            }\n            pending = true;\n            const queue = _idleEffects;\n            if (queue.length === 0) {\n                _requestIdleCallback(_flushIdleEffects);\n            }\n            queue.push(() => {\n                if (pending === true) {\n                    pending = false;\n                    if (reset !== void 0) {\n                        reset();\n                    }\n                    reset = hook(next);\n                }\n            });\n        }\n        prev = next;\n    };\n};\n/**\n * Invalidates a component.\n *\n * @param c Component instance.\n */\nexport const invalidate = (c) => {\n    if (!(c.f & 128 /* Flags.Dirty */)) {\n        c.f |= 128 /* Flags.Dirty */;\n        let prev = c;\n        let parent = c.p;\n        while (parent !== null) {\n            // Polymorphic call-sites\n            if (parent.f & 256 /* Flags.DirtySubtree */) {\n                return;\n            }\n            prev = parent;\n            parent.f |= 256 /* Flags.DirtySubtree */;\n            parent = parent.p;\n        }\n        prev.v.d.p1(prev, prev.s1);\n    }\n};\n/**\n * VDescriptor for List nodes.\n */\nexport const LIST_DESCRIPTOR = {\n    f: 4 /* Flags.List */,\n    p1: null,\n    p2: null,\n};\n/**\n * Creates a dynamic list.\n *\n * @typeparam E Entry type.\n * @typeparam K Key type.\n * @param entries Entries.\n * @param getKey Get key from entry function.\n * @param render Render entry function.\n * @returns Dynamic list.\n */\nexport const List = (entries, getKey, render) => ({\n    d: LIST_DESCRIPTOR,\n    p: {\n        k: entries.map(getKey),\n        v: entries.map(render),\n    },\n});\n/**\n * Performs dirty checking in a root subtree.\n *\n * When `forceUpdate` option is enabled, all components in a root subtree will\n * be updated.\n *\n * @param root Root Node.\n * @param forceUpdate Force update components.\n */\nexport const dirtyCheck = (root, forceUpdate) => {\n    _dirtyCheckRoot(root, forceUpdate === true\n        ? 512 /* Flags.ForceUpdate */\n        : 0);\n};\n/**\n * Performs a Dirty Checking in a root subtree.\n *\n * @param root Stateful Root Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _dirtyCheckRoot = (root, updateFlags) => {\n    while ((updateFlags | root.f) & (256 /* Flags.DirtySubtree */ | 512 /* Flags.ForceUpdate */)) {\n        const ctx = RENDER_CONTEXT;\n        const { p, n } = ctx;\n        root.f = 32 /* Flags.Root */;\n        if (root.c !== null) {\n            const domSlot = root.v.p;\n            RENDER_CONTEXT.p = domSlot.p;\n            RENDER_CONTEXT.n = domSlot.n;\n            _dirtyCheck(root.c, updateFlags);\n            updateFlags = 0;\n            _flushDOMEffects();\n        }\n        ctx.p = p;\n        ctx.n = n;\n    }\n};\n/**\n * Updates a root subtree.\n *\n * @param root Stateful Root Node.\n * @param next New Stateless Node.\n * @param updateFlags Update flags (ForceUpdate and DisplaceNode).\n */\nconst _updateRoot = (root, next, updateFlags) => {\n    const ctx = RENDER_CONTEXT;\n    const { p, n } = ctx;\n    const domSlot = root.v.p;\n    ctx.p = domSlot.p;\n    ctx.n = domSlot.n;\n    root.f = 32 /* Flags.Root */;\n    root.c = _update(root, root.c, next, updateFlags);\n    _flushDOMEffects();\n    ctx.p = p;\n    ctx.n = n;\n    _dirtyCheckRoot(root, 0);\n};\n/**\n * Unmounts a root subtree.\n *\n * When `detach` option is enabled, root DOM nodes will be detached from the\n * DOM.\n *\n * @param root Root Node.\n * @param detach Detach root DOM nodes from the DOM.\n */\nexport const unmount = (root, detach) => {\n    if (root.c !== null) {\n        const ctx = RENDER_CONTEXT;\n        const { p, n } = ctx;\n        ctx.p = root.v.p.p;\n        root.f = 32 /* Flags.Root */;\n        _unmount(root.c, detach);\n        ctx.p = p;\n        ctx.n = n;\n    }\n};\n/**\n * Hydrates a root subtree.\n *\n * @param root Root Node.\n * @param v Stateless View Node.\n */\nexport const hydrate = (root, v) => {\n    const domSlot = root.v.p;\n    RENDER_CONTEXT.p = domSlot.p;\n    RENDER_CONTEXT.n = domSlot.n;\n    root.c = _hydrate(root, v);\n    _flushDOMEffects();\n    _dirtyCheckRoot(root, 0);\n};\n/**\n * Hydrates Node.\n *\n * @param parentSNode Parent Stateful Node.\n * @param v Stateless Node.\n * @returns Hydrated Stateful Node.\n */\nconst _hydrate = (parentSNode, v) => {\n    if (v !== false && v != null) {\n        if (typeof v === \"object\") {\n            if (_isArray(v)) {\n                return _hydrateList(parentSNode, 8 /* Flags.Array */, v, v);\n            }\n            else {\n                const descriptor = v.d;\n                const props = v.p;\n                const type = descriptor.f & 127 /* Flags.TypeMask */;\n                if (type === 1 /* Flags.Template */) {\n                    const ctx = RENDER_CONTEXT;\n                    const tplData = descriptor.p1;\n                    const stateOpCodes = tplData.s;\n                    const propOpCodes = tplData.p;\n                    const data = tplData.d;\n                    const flags = tplData.f;\n                    const state = _Array(flags & 63 /* TemplateFlags.Mask6 */);\n                    const currentDOMNode = ctx.n === null\n                        ? nodeGetLastChild.call(ctx.p)\n                        : nodeGetPreviousSibling.call(ctx.n);\n                    state[0] = currentDOMNode;\n                    if (stateOpCodes.length > 0) {\n                        ctx.si = 0;\n                        _hydrateAssignTemplateSlots(currentDOMNode, nodeGetFirstChild.call(currentDOMNode), stateOpCodes, 0, stateOpCodes.length, state);\n                    }\n                    if (propOpCodes.length > 0) {\n                        let currentElement = currentDOMNode;\n                        for (let i = 0; i < propOpCodes.length; i++) {\n                            const op = propOpCodes[i];\n                            const type = op & 7 /* PropOpCode.TypeMask */;\n                            const dataIndex = op >> 9 /* PropOpCode.DataShift */;\n                            // TODO: optimize (skip attributes)\n                            if (type === 0 /* PropOpCode.SetNode */) {\n                                currentElement = state[dataIndex];\n                            }\n                            else {\n                                const prop = props[(op >> 3 /* PropOpCode.InputShift */) & 63 /* PropOpCode.Mask6 */];\n                                if (type === 7 /* PropOpCode.Directive */) {\n                                    prop(currentElement, true);\n                                }\n                                else {\n                                    const key = data[dataIndex];\n                                    if (type === 6 /* PropOpCode.Event */) {\n                                        if (prop != null && prop !== false) {\n                                            elementAddEventListener.call(currentElement, key, prop);\n                                        }\n                                    }\n                                    else { // type === PropOpCode.Property || type === PropOpCode.DiffDOMProperty\n                                        if (currentElement[key] !== prop) {\n                                            currentElement[key] = prop;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    const parentElement = ctx.p;\n                    const stateNode = createSNode(1 /* Flags.Template */, v, null, parentSNode, state);\n                    const childrenSize = (flags >> 6 /* TemplateFlags.ChildrenSizeShift */) & 63 /* TemplateFlags.Mask6 */;\n                    if (childrenSize > 0) {\n                        const childOpCodes = tplData.c;\n                        const children = _Array(childrenSize);\n                        stateNode.c = children;\n                        ctx.p = currentDOMNode;\n                        ctx.n = null;\n                        let childrenIndex = 0;\n                        for (let i = 0; i < childOpCodes.length; i++) {\n                            const childOpCode = childOpCodes[i];\n                            const type = childOpCode & 3 /* ChildOpCode.Type */;\n                            const value = childOpCode >> 2 /* ChildOpCode.ValueShift */;\n                            if (type === 0 /* ChildOpCode.Child */) {\n                                children[childrenIndex++] = _hydrate(stateNode, props[value]);\n                            }\n                            else if (type === 1 /* ChildOpCode.SetNext */) {\n                                ctx.n = state[value];\n                            }\n                            else { // ChildOpCode.SetParent\n                                ctx.p = state[value];\n                                ctx.n = null;\n                            }\n                        }\n                        ctx.p = parentElement;\n                    }\n                    ctx.n = currentDOMNode;\n                    return stateNode;\n                }\n                else if (type === 2 /* Flags.Component */) {\n                    const sNode = {\n                        f: 2 /* Flags.Component */,\n                        v: v,\n                        c: null,\n                        p: parentSNode,\n                        s1: null,\n                        s2: null,\n                    };\n                    const renderFn = descriptor.p1(sNode);\n                    sNode.c = _hydrate(sNode, renderFn(props));\n                    sNode.s1 = renderFn;\n                    return sNode;\n                }\n                else if (type === 4 /* Flags.List */) {\n                    return _hydrateList(parentSNode, 4 /* Flags.List */, props.v, v);\n                }\n                // Context\n                const sNode = createSNode(64 /* Flags.Context */, v, null, parentSNode, null);\n                sNode.c = _hydrate(sNode, props.c);\n                return sNode;\n            }\n        }\n        else if (v !== \"\") { // Text\n            const ctx = RENDER_CONTEXT;\n            let node = ctx.n === null\n                ? nodeGetLastChild.call(ctx.p)\n                : nodeGetPreviousSibling.call(ctx.n);\n            // Edge case: [dynamic text, dynamic text]\n            while (nodeGetNodeType.call(node) === 8 /* NodeType.Comment */) {\n                const comment = node;\n                node = nodeGetPreviousSibling.call(node);\n                comment.remove();\n            }\n            ctx.n = node;\n            return createSNode(16 /* Flags.Text */, v, null, parentSNode, node);\n        }\n    }\n    return null;\n};\nconst _hydrateList = (parentState, flags, children, vNode) => {\n    let i = children.length;\n    const sChildren = _Array(i);\n    const sNode = createSNode(flags, vNode, sChildren, parentState, null);\n    while (i > 0) {\n        sChildren[--i] = _hydrate(sNode, children[i]);\n    }\n    return sNode;\n};\nconst _parseInt = parseInt;\nconst _parseOffset = (s, _i) => _parseInt(s, 16);\nconst _hydrateAssignTemplateSlots = (parentElement, currentNode, opCodes, offset, endOffset, state) => {\n    const ctx = RENDER_CONTEXT;\n    let exprOffsetIndex = 0;\n    let exprOffsets;\n    // text edge cases:\n    //\n    //   [text, { element }, text]\n    //                      ^ prevExpr flag\n    //\n    //   [text, <!>, { text }, <!>, { text }, <!>, text]\n    //                                       ^ prevExpr flag\n    //         [            ] [            ] [         ]\n    //\n    while (true) {\n        const op = opCodes[offset++];\n        if (op & 4 /* StateOpCode.PrevExpr */) {\n            // Lazy getAttribute call.\n            if (exprOffsets === void 0) {\n                exprOffsets = elementGetAttribute.call(parentElement, \"&\")\n                    .split(\" \")\n                    .map(_parseOffset);\n            }\n            let exprOffset = exprOffsets[exprOffsetIndex++];\n            while (exprOffset-- > 0) {\n                if (nodeGetNodeType.call(currentNode) === 8 /* NodeType.Comment */) {\n                    const comment = currentNode;\n                    currentNode = nodeGetNextSibling.call(currentNode);\n                    comment.remove();\n                }\n                currentNode = nodeGetNextSibling.call(currentNode);\n            }\n        }\n        if (op & 1 /* StateOpCode.Save */) {\n            state[++ctx.si] = currentNode;\n        }\n        if (op & 2 /* StateOpCode.EnterOrRemove */) {\n            const enterOffset = op >> 3 /* StateOpCode.OffsetShift */;\n            // Enter offset is used to disambiguate between enter and remove\n            // operations. Remove operations will always have a 0 enterOffset.\n            if (enterOffset) { // Enter\n                let node = nodeGetFirstChild.call(currentNode);\n                _hydrateAssignTemplateSlots(currentNode, node, opCodes, offset, offset += enterOffset, state);\n            }\n            else { // Remove\n                // Remove operation implies that current node can be a comment node\n                // followed by a text node.\n                if (nodeGetNodeType.call(currentNode) === 8 /* NodeType.Comment */) {\n                    const comment = currentNode;\n                    currentNode = nodeGetNextSibling.call(currentNode);\n                    comment.remove();\n                }\n                state[++ctx.si] = currentNode;\n            }\n        }\n        if (offset === endOffset) {\n            return;\n        }\n        currentNode = nodeGetNextSibling.call(currentNode);\n    }\n};\n/**\n * Defines a root node with a custom invalidation hook.\n *\n * @param onInvalidate Invalidated Hook.\n * @returns Root Node factory.\n */\nexport const defineRoot = (p1) => {\n    var d = { f: 32 /* Flags.Root */, p1, p2: null };\n    return (p, n = null, s) => createSNode(32 /* Flags.Root */, \n    // VNode object.\n    {\n        // Root Descriptor.\n        d,\n        // VNode props object contains the location in the DOM tree where subtree\n        // should be rendered.\n        p: {\n            // Parent DOM Element.\n            p,\n            // Next DOM Node.\n            n,\n        },\n    }, \n    // Children.\n    null, \n    // Parent SNode.\n    null, \n    // Root state.\n    s);\n};\n/**\n * Creates a root node that uses microtask queue for scheduling updates.\n *\n * @param parentElement Parent DOM Element.\n * @param nextNode Next DOM Node.\n * @returns Root Node.\n */\nexport const createRoot = /*@__PURE__*/ defineRoot(\n// OnRootInvalidated hook\n(root) => {\n    // Schedules a microtask for dirty checking.\n    _queueMicrotask(() => {\n        _dirtyCheckRoot(root, 0);\n    });\n});\n/**\n * Updates a root subtree.\n *\n * When `forceUpdate` option is enabled, all components in a root subtree will\n * be updated.\n *\n * @param root Root Node.\n * @param v Stateless View Node.\n * @param forceUpdate Force update components.\n */\nexport const update = (root, v, forceUpdate) => {\n    _updateRoot(root, v, forceUpdate === true\n        ? 512 /* Flags.ForceUpdate */\n        : 0);\n};\nexport const context = () => {\n    const d = { f: 64 /* Flags.Context */, p1: null, p2: null };\n    return [\n        (c) => _getContextValue(c, d),\n        (v, c) => ({ d, p: { v, c } }),\n    ];\n};\nconst _getContextValue = (c, d) => {\n    let node = c.p;\n    while (node !== null) {\n        if (node.f & 64 /* Flags.Context */ && node.v.d === d) {\n            return node.v.p.v;\n        }\n        node = node.p;\n    }\n};\n//# sourceMappingURL=core.js.map",null],"names":["__IVI_DATA__","_Object","Object","_Array","Array","_isArray","isArray","_Map","Map","_Int32Array","Int32Array","_queueMicrotask","queueMicrotask","nodeProto","Node","prototype","elementProto","Element","doc","document","HTM_TEMPLATE","createElement","HTM_TEMPLATE_CONTENT","content","firstChild","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","removeAttribute","elementAddEventListener","addEventListener","elementRemoveEventListener","removeEventListener","getDescriptor","o","p","getOwnPropertyDescriptor","nodeGetFirstChild","get","nodeGetNextSibling","nodeSetTextContent","set","elementSetInnerHTML","elementSetClassName","htmlElementGetStyle","HTMLElement","svgElementGetStyle","SVGElement","RENDER_CONTEXT","seal","n","si","e","createSNode","f","v","c","s1","_flushDOMEffects","length","i","_updateTemplateProperties","currentElement","opCodes","data","state","prevProps","nextProps","svg","style","op","type","dataIndex","propsIndex","next","key","prev","call","nodeValue","setProperty","removeProperty","_assignTemplateSlots","currentNode","offset","endOffset","ctx","enterOffset","commentNode","remove","_mountList","parentState","flags","children","vNode","sChildren","sNode","_mount","_update","parentSNode","updateFlags","_unmount","_dirtyCheck","_updateArray","prevSChildren","nextSChildren","prevLength","nextLength","sChild","descriptor","d","p2","parentElement","tplData","p1","propsOpCodes","childOpCodes","rootDOMNode","childrenIndex","childOpCode","value","_updateList","props","descriptorP1","parentDOMElement","nextDOMNode","stateOpCodes","s","s2","renderFn","createTextNode","detach","unmountHooks","a","b","aKeys","k","bKeys","bVNodes","bLength","aLength","result","aEnd","bEnd","start","outer","sources","keyIndex","j","nodePosition","nextPosition","markLIS","node","lisValue","parent","index","lo","hi","indexLength","_T","LIST_DESCRIPTOR","_dirtyCheckRoot","root","domSlot","createRoot","defineRoot","_tpl_","t","innerHTML","_h","template","items","List","entries","map","item","id","_t","date","classname","title","footer","render","rootEl","update","_updateRoot"],"mappings":"AAUA,MAAMA,EAAyC,CAAA,YAAA,UAAA,cAKzCC,EAAUC,OACVC,EAASC,MACTC,EAA0CF,EAAOG,QACjDC,EAAOC,IACPC,EAAcC,WACdC,EAAkBC,eAIlBC,EAAYC,KAAKC,UACjBC,EAAeC,QAAQF,UACvBG,EAAMC,SAINC,EAA6BF,EAAIG,cAAc,YAC/CC,EAAuBF,EAAaG,QACNL,EAAIG,cAAc,YAGXE,QAAQC,WAMnD,MAAMC,EAAmFZ,EAAUa,aAE7FC,EAA8Dd,EAAUe,YAExEC,EAAkEhB,EAAUiB,UAI5EC,EAAqFf,EAAagB,aAElGC,EAAyEjB,EAAakB,gBAEtFC,EAA0BnB,EAAaoB,iBAEvCC,EAA6BrB,EAAasB,oBAG1CC,EAAgBA,CAACC,EAAQC,IAAgCxC,EAAQyC,yBAAyBF,EAAGC,GAG7FE,EAAmEJ,EAAc1B,EAAW,cAAe+B,IAEzCL,EAAc1B,EAAW,aAAc+B,IAE/G,MAAMC,EAAoEN,EAAc1B,EAAW,eAAgB+B,IAErCL,EAAc1B,EAAW,mBAAoB+B,IAE3H,MAAME,EAAgFP,EAAc1B,EAAW,eAAgBkC,IAElER,EAAc1B,EAAW,YAAa+B,IAEnG,MAAMI,EAA2ET,EAAcvB,EAAc,aAAc+B,IAErHE,EAA2EV,EAAcvB,EAAc,aAAc+B,IAErHG,EAA+EX,EAAcY,YAAYpC,UAAW,SAAU6B,IAE9HQ,EAA6Eb,EAAcc,WAAWtC,UAAW,SAAU6B,IAqBpHU,EAAgCrD,EAAQsD,KAAK,CACxDd,EAAG,KACHe,EAAG,KACHC,GAAI,EACJC,EAAG,KA0GQC,EAAcA,CACzBC,EACAC,EACAC,EACArB,EACAsB,KACkB,CAAEH,IAAGC,IAAGC,IAAGrB,IAAGsB,OAyHrBC,EAAmBA,KAC9B,MAAMN,EAAIJ,EAAeI,EACzB,GAAIA,EAAEO,OAAS,EAAG,CAChBX,EAAeI,EAAI,GACnB,IAAK,IAAIQ,EAAI,EAAGA,EAAIR,EAAEO,OAAQC,IAC5BR,EAAEQ,IAEN,GAGIC,EAA4BA,CAChCC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,KAEA,IAAIC,EACJ,IAAK,IAAIT,EAAI,EAAGA,EAAIG,EAAQJ,OAAQC,IAAK,CACvC,MAAMU,EAAKP,EAAQH,GACbW,EAAS,EAAFD,EACPE,EAAYF,GAAE,EACpB,GAAiC,IAA7BC,EACFT,EAAiBG,EAAMO,GACvBH,OAAQ,MACH,CACL,MAAMI,EAAcH,GAA4B,EAAA,GAC1CI,EAAOP,EAAUM,GAEvB,GAAyC,IAArCF,EAAqC,CACvC,MAAMI,EAAMX,EAAKQ,GACC,OAAdN,OACW,IAATQ,IACDZ,EAAuCa,GAAOD,GAEvCZ,EAAuCa,KAASD,IACzDZ,EAAuCa,GAAOD,EAEnD,KAAO,CACL,IAAIE,EAKJ,GAJkB,OAAdV,IACFU,EAAOV,EAAUO,IAGfG,IAASF,EACX,GAAgC,IAA5BH,EAC0C,IAAxCC,EACW,KAATE,GAAuB,MAARA,IAAyB,IAATA,EACjC/B,EAAoBkC,KAAKf,EAAgBY,GACvB,KAATE,GAAuB,MAARA,IAAyB,IAATA,GACxCjC,EAAoBkC,KAAKf,EAAgB,IAEQ,IAA1CU,EACI,KAATE,GAAuB,MAARA,IAAyB,IAATA,EACrB,MAARE,GAAyB,KAATA,IAAwB,IAATA,EACjCpC,EAAmBqC,KAAKf,EAAgBY,GAExCrC,EAAkBwC,KAAKf,GAAiBgB,UAAYJ,EAErC,MAARE,GAAyB,KAATA,IAAwB,IAATA,GACxCpC,EAAmBqC,KAAKf,EAAgB,IAG7B,KAATY,GAAuB,MAARA,IAAyB,IAATA,EACjChC,EAAoBmC,KAAKf,EAAgBY,GACvB,KAATE,GAAuB,MAARA,IAAyB,IAATA,GACxCpC,EAAmBqC,KAAKf,EAAgB,SAGvC,GAAmC,IAA/BS,EACRG,EAA0BZ,OACtB,CACL,MAAMa,EAAMX,EAAKQ,GACkB,IAA/BD,GACW,IAATG,GAA0B,MAARA,EACpBjD,EAAoBoD,KAAKf,EAAgBa,EAAKD,IAC5B,IAATE,GAA0B,MAARA,GAC3BjD,EAAuBkD,KAAKf,EAAgBa,GAEP,IAA9BJ,EACRT,EAAuCa,GAAOD,EACX,IAA3BH,GACI,IAATG,GAA0B,MAARA,QACN,IAAVL,IACFA,GAAiB,IAARD,EACLxB,EAAoBiC,KAAKf,GACzBhB,EAAmB+B,KAAKf,IAE9BO,EAAOU,YAAYJ,EAAKD,KACN,IAATE,GAA0B,MAARA,SACb,IAAVP,IACFA,GAAiB,IAARD,EACLxB,EAAoBiC,KAAKf,GACzBhB,EAAmB+B,KAAKf,IAE9BO,EAAOW,eAAeL,KAGZ,MAARC,IAAyB,IAATA,GAClB7C,EAA2B8C,KAAKf,EAAgBa,EAAKC,GAE3C,MAARF,IAAyB,IAATA,GAClB7C,EAAwBgD,KAAKf,EAAgBa,EAAKD,GAGxD,CAEJ,CACF,CACF,GAGIO,EAAuBA,CAC3BC,EACAnB,EACAoB,EACAC,EACAnB,KAEA,MAAMoB,EAAMrC,EACZ,OAAa,CACX,MAAMsB,EAAKP,EAAQoB,KAInB,GAH2B,EAAvBb,IACFL,IAAQoB,EAAIlC,IAAM+B,GAEgB,EAAhCZ,EAAgC,CAClC,MAAMgB,EAAchB,GAAE,EAGtB,GAAIgB,EACFL,EACE5C,EAAkBwC,KAAKK,GACvBnB,EACAoB,EACAA,GAAUG,EACVrB,OAEG,CAGL,MAAMsB,EAAcL,EACpBjB,IAAQoB,EAAIlC,IAAM+B,EAAc3C,EAAmBsC,KAAKK,GACxDK,EAAYC,QACd,CACF,CACA,GAAIL,IAAWC,EACb,OAEFF,EAAc3C,EAAmBsC,KAAKK,EACxC,GAGIO,EAAaA,CACjBC,EACAC,EACAC,EACAC,KAEA,IAAIjC,EAAIgC,EAASjC,OACjB,MAAMmC,EAAYjG,EAAO+D,GACnBmC,EAAQ1C,EAAYsC,EAAOE,EAAOC,EAAWJ,EAAa,MAChE,KAAO9B,EAAI,GACTkC,IAAYlC,GAAKoC,EAAOD,EAAOH,EAAShC,IAE1C,OAAOmC,CAAK,EAiDRE,EAAUA,CACdC,EACAH,EACArB,EACAyB,KAEA,GAAc,OAAVJ,EACF,OAAOC,EAAOE,EAAaxB,GAE7B,IAAa,IAATA,GAA0B,MAARA,GAAyB,KAATA,EAEpC,OADA0B,EAASL,GAAO,GACT,KAIT,MAAMH,EAAWG,EAAMvC,EACjBoB,EAAOmB,EAAMxC,EACbU,EAAQ8B,EAAMtC,GACdkC,EAAQI,EAAMzC,EACdiB,EAAY,IAALoB,EAUb,GATAI,EAAMzC,EAAIiB,EAIVwB,EAAMxC,EAAImB,EAKe,KAArBH,EAAqB,CACvB,MAAMc,EAAMrC,EACZ,MAAoB,iBAAT0B,GACLE,IAASF,IACVT,EAAea,UAAYJ,GAEQ,KAAlCyB,GACFhF,EAAkB0D,KAChBQ,EAAIlD,EACH8B,EACDoB,EAAInC,GAGRmC,EAAInC,EAAIe,EACD8B,IAET1E,EAAiBwD,KAAKQ,EAAIlD,EAAI8B,GACvB+B,EAAOE,EAAaxB,GAC7B,CAEA,GAAIE,IAASF,EAEX,OADA2B,EAAYN,EAAOI,GACZJ,EAKT,GAFAA,EAAMzC,EAAIiB,EAEgB,IAAtBA,EACF,MAvGiB+B,EACnBJ,EACAH,EACArB,EACAyB,KAEA,IAAKpG,EAAS2E,GAEZ,OADA0B,EAASL,GAAO,GACTC,EAAOE,EAAaxB,GAE7B,MAAM6B,EAAgBR,EAAMvC,EAC5B,IAAIgD,EAAgBD,EAChBE,EAAaF,EAAc5C,OAC3B+C,EAAahC,EAAKf,OACtB,GAAI+C,IAAeD,EAAY,CAE7B,IADAV,EAAMvC,EAAIgD,EAAgB3G,EAAO6G,GAC1BD,EAAaC,GAAY,CAC9B,MAAMC,EAASJ,IAAgBE,GAChB,OAAXE,GACFP,EAASO,GAAQ,EAErB,CACA,KAAOD,EAAaD,GAClBD,IAAgBE,GAAcV,EAAOD,EAAOrB,EAAKgC,GAErD,CACA,KAAOA,EAAa,GAClBF,IAAgBE,GAAcT,EAC5BF,EACAQ,EAAcG,GACdhC,EAAKgC,GACLP,GAGJ,OAAOJ,CAAK,EAqEHO,CAAaJ,EAAaH,EAAOrB,EAAMyB,GAGhD,MAAMS,EAAclC,EAAemC,EAC7B1C,EAAaO,EAAevC,EAC5B+B,EAAaU,EAAezC,EAClC,GAAKyC,EAAeiC,IAAMD,EAExB,OADAR,EAASL,GAAO,GACTC,EAAOE,EAAaxB,GAG7B,GAA8B,IAA1BH,EAE0B,KAAxBoB,EAAQQ,SACS,IAAlBS,EAAWE,KAC6B,IAAxCF,EAAWE,GAAG5C,EAAWC,GAE1B4B,EAAMvC,EAAIyC,EACRF,EACAH,EACC3B,EAA4BE,GAC7BgC,GAEoB,OAAbP,GACTS,EAAYT,EAAmBO,QAE5B,GAA6B,IAAzB5B,EAAyB,CAClC,MAAMc,EAAMrC,EACN+D,EAAgB1B,EAAIlD,EACpB6E,EAAWJ,EAAkCK,GAC7CtB,EAAQqB,EAAQ1D,EAChBU,EAAOgD,EAAQH,EACfK,EAAeF,EAAQ7E,EACvBgF,EAAeH,EAAQxD,EACvB4D,EAAcnD,EAAM,GAiB1B,GAfsC,KAAlCkC,IACFA,GAAW,KACXhF,EAAkB0D,KAAKkC,EAAeK,EAAa/B,EAAInC,IAGzDW,EACEuD,EACAF,EACAlD,EACAC,EACAC,EACAC,UACGwB,IAGY,OAAbC,EAAmB,CACrBP,EAAIlD,EAAIiF,EACR/B,EAAInC,EAAI,KAER,IAAImE,EAAgB,EACpB,IAAK,IAAIzD,EAAI,EAAGA,EAAIuD,EAAaxD,OAAQC,IAAK,CAC5C,MAAM0D,EAAcH,EAAavD,GAC3BW,EAAkB,EAAX+C,EACPC,EAAQD,GAAW,EACO,IAA5B/C,EACDqB,EAA8ByB,GAC7BpB,EACEF,EACCH,EAA8ByB,KAC/BlD,EAAUoD,GACVpB,GAEmC,IAA9B5B,EACTc,EAAInC,EAAIe,EAAMsD,IAEdlC,EAAIlD,EAAI8B,EAAMsD,GACdlC,EAAInC,EAAI,KAEZ,CAEAmC,EAAIlD,EAAI4E,CACV,CAEA1B,EAAInC,EAAIkE,OACsB,IAArB7C,EACTiD,EACEzB,EACA7B,EACAC,EACAgC,IAGEjC,EAAUX,IAAMY,EAAUZ,IAC5B4C,GAAW,KAEbJ,EAAMvC,EAAIyC,EACRF,EACAH,EACAzB,EAAUX,EACV2C,IAIJ,OAAOJ,CAAK,EAURC,EAASA,CAACE,EAAoB3C,KAClC,IAAU,IAANA,GAAoB,MAALA,EAAW,CAC5B,GAAiB,iBAANA,EAAgB,CACzB,GAAIxD,EAASwD,GACX,OAAOkC,EAAWS,IAA0B3C,EAAGA,GAC1C,CACL,MAAMqD,EAAarD,EAAEsD,EACfY,EAAQlE,EAAEpB,EACVuF,EAAed,EAAWK,GAC1B1C,EAAuB,EAAhBqC,EAAWtD,EACxB,GAA6B,IAAzBiB,EAAyB,CAC3B,MAAMc,EAAMrC,EACN2E,EAAmBtC,EAAIlD,EACvByF,EAAcvC,EAAInC,EAClB8D,EAAUU,EACV1D,EAAOgD,EAAQH,EACfK,EAAeF,EAAQ7E,EACvB0F,EAAeb,EAAQc,EACvBX,EAAeH,EAAQxD,EACvBmC,EAAQqB,EAAQ1D,EAChB8D,EAAeR,EAAkCE,KACjD7C,EAAQpE,KAAa8F,GAC3B1B,EAAM,GAAKmD,EAEPS,EAAalE,OAAS,IACxB0B,EAAIlC,GAAK,EACT8B,EACE5C,EAAkBwC,KAAKuC,GACvBS,EACA,EACAA,EAAalE,OACbM,IAGJJ,EACEuD,EACAF,EACAlD,EACAC,EACA,KACAwD,UACG9B,IAGL,MAAMI,EAAQ1C,EAEZE,EAAAA,EACA,KACA2C,EACAjC,GAEF,GAAIkD,EAAaxD,OAAS,EAAG,CAC3B,MAAMiC,EAAW/F,EACd8F,GAAK,EAAoC,IAE5CI,EAAMvC,EAAIoC,EACVP,EAAIlD,EAAIiF,EACR/B,EAAInC,EAAI,KACR,IAAImE,EAAgB,EACpB,IAAK,IAAIzD,EAAI,EAAGA,EAAIuD,EAAaxD,OAAQC,IAAK,CAC5C,MAAM0D,EAAcH,EAAavD,GAC3BW,EAAkB,EAAX+C,EACPC,EAAQD,GAAW,EACO,IAA5B/C,EACFqB,EAASyB,KAAmBrB,EAAOD,EAAO0B,EAAMF,IACT,IAA9BhD,EACTc,EAAInC,EAAIe,EAAMsD,IAEdlC,EAAIlD,EAAI8B,EAAMsD,GACdlC,EAAInC,EAAI,KAEZ,CACAmC,EAAIlD,EAAIwF,CACV,CAIA,OAHAtC,EAAInC,EAAIkE,EAERjG,EAAkB0D,KAAK8C,EAAkBP,EAAaQ,GAC/C7B,EACF,GAA8B,IAA1BxB,EAA0B,CACnC,MAAMwB,EAAmB,CACvBzC,EAAC,EACDC,EAAGA,EACHC,EAAG,KACHrB,EAAG+D,EACHzC,GAAI,KACJsE,GAAI,MAEAC,EAAYN,EAAoC3B,GAGtD,OAFAA,EAAMvC,EAAIwC,EAAOD,EAAOiC,EAASP,IACjC1B,EAAMtC,GAAKuE,EACJjC,EACF,GAAyB,IAArBxB,EACT,OAAOkB,EAAWS,EAAW,EAAeuB,EAAoBlE,EAAGA,GAGrE,MAAMwC,EAAQ1C,EAA2BE,GAAAA,EAAG,KAAM2C,EAAa,MAE/D,OADAH,EAAMvC,EAAIwC,EAAOD,EAAQ0B,EAAuBjE,GACzCuC,CACT,CACF,CAAO,GAAU,KAANxC,EAAU,CACnB,MAAM8B,EAAMrC,EACN0B,EAAOW,EAAInC,EACXE,EAAIxC,EAAIqH,eAAe1E,GAG7B,OAFA8B,EAAInC,EAAIE,EACRjC,EAAiB0D,KAAKQ,EAAIlD,EAAGiB,EAAGsB,GACzBrB,KAAwBE,EAAG,KAAM2C,EAAa9C,EACvD,CACF,CACA,OAAO,IAAI,EASPiD,EAAcA,CAACN,EAAcI,KACjC,MAAMd,EAAMrC,EAENiB,EAAQ8B,EAAMtC,GACdF,EAAIwC,EAAMxC,EACVqC,EAAWG,EAAMvC,EACjBmC,EAAQI,EAAMzC,EACdiB,EAAY,IAALoB,EAEb,GADAI,EAAMzC,EAAIiB,EACmB,IAAzBA,EAAyB,CAC3B,MAAM6C,EAAenD,EAAiB,GAKtC,GAJsC,KAAlCkC,IACFA,GAAW,KACXhF,EAAiB0D,KAAKQ,EAAIlD,EAAGiF,EAAa/B,EAAInC,IAEhB,IAA5ByC,EAA4B,CAC9BN,EAAIlD,EAAIiF,EACR/B,EAAInC,EAAI,KACR,MAAMyE,EAAmBtC,EAAIlD,EACvBgF,EAAgB5D,EAAgBsD,EAAEI,GAAGzD,EAC3C,IAAI6D,EAAgB,EACpB,IAAK,IAAIzD,EAAI,EAAGA,EAAIuD,EAAaxD,OAAQC,IAAK,CAC5C,MAAMU,EAAK6C,EAAavD,GAClBW,EAAS,EAAFD,EACPiD,EAAQjD,GAAE,EAChB,GAAgC,IAA5BC,EAA4B,CAC9B,MAAMoC,EAAUf,EAA+ByB,KAChC,OAAXV,GACFN,EAAYM,EAAQR,QAEiB,IAA9B5B,EACTc,EAAInC,EAAKe,EAAiBsD,IAE1BlC,EAAIlD,EAAI8B,EAAMsD,GACdlC,EAAInC,EAAI,KAEZ,CACAmC,EAAIlD,EAAIwF,CACV,CACAtC,EAAInC,EAAIkE,OACH,GAAyB,KAArB7C,EAC6B,KAAlC4B,GACFhF,EAAiB0D,KAAKQ,EAAIlD,EAAG8B,EAAeoB,EAAInC,GAElDmC,EAAInC,EAAIe,OACH,GAA8B,IAA1BM,EACe,KAAnBoB,EAAQQ,GACXJ,EAAMvC,EAAIyC,EACRF,EACAH,EACC3B,EAA8BV,EAAiBpB,GAChDgE,GAEoB,OAAbP,GACTS,EAAYT,EAAmBO,QAE5B,GAA4B,KAAxB5B,EACQ,OAAbqB,GACFS,EAAYT,EAAmBO,OAE5B,CACL,IAAIvC,EAAKgC,EAAiCjC,OAC1C,OAASC,GAAK,GAAG,CACf,MAAM+C,EAAUf,EAAiChC,GAClC,OAAX+C,GACFN,EAAYM,EAAQR,EAExB,CACF,GASIC,EAAWA,CAACL,EAAcmC,KAC9B,MAAMvC,EAAQI,EAAMzC,EACdwC,EAAYC,EAAMvC,EAWxB,IATe,IAAX0E,GAAyB,GAALvC,IACtBuC,GAAS,EACT7G,EAAgBwD,KACd7B,EAAeb,EACT,EAALwD,EACII,EAAoBtC,GAAG,GACvBsC,EAAgBtC,KAGI,EAAzBkC,EAAyB,CAC3B,MAAMwC,EAAgBpC,EAAqBgC,GAC3C,GAAqB,OAAjBI,EACF,GAA4B,mBAAjBA,EACTA,SAEA,IAAK,IAAIvE,EAAI,EAAGA,EAAIuE,EAAaxE,OAAQC,IACvCuE,EAAavE,IAIrB,CAEA,GAAkB,OAAdkC,EACF,GAAI/F,EAAS+F,GACX,IAAK,IAAIlC,EAAI,EAAGA,EAAIkC,EAAUnC,OAAQC,IAAK,CACzC,MAAM+C,EAASb,EAAUlC,GACV,OAAX+C,GACFP,EAASO,EAAQuB,EAErB,MAEA9B,EAASN,EAAoBoC,EAEjC,EAwQIV,EAAcA,CAClBzB,EACAqC,EACAC,EACAlC,KAEA,MAAMmC,EAAQF,EAAEG,EACVC,EAAQH,EAAEE,EACVE,EAAUJ,EAAE9E,EAClB,IAAImF,EAAUF,EAAM7E,OAChBgF,EAAUL,EAAM3E,OACpB,MAAMiF,EAAS/I,EAAO6I,GAEtB,GAAgB,IAAZA,EACEC,EAAU,GACZvC,EAASL,GAAO,QAEb,GAAgB,IAAZ4C,EACT,KAAOD,EAAU,GACfE,IAASF,GAAW1C,EAAOD,EAAO0C,EAAQC,QAEvC,CACL,MAAM5C,EAAYC,EAAMvC,EACxB,IAAIqF,EAAOF,EAAU,EACjBG,EAAOJ,EAAU,EACjBK,EAAQ,EAGZC,EAAO,OAAa,CAElB,KAAOV,EAAMO,KAAUL,EAAMM,IAO3B,GANAF,EAAOE,GAAQ7C,EACbF,EACAD,EAAU+C,KACVJ,EAAQK,GACR3C,GAEE4C,IAAUD,GAAQC,EAAQF,EAC5B,MAAMG,EAKV,KAAOV,EAAMS,KAAWP,EAAMO,MAAYA,GAASF,GAAQE,GAASD,IAIpE,KACF,CAGA,GAAIC,EAAQF,EAEV,KAAOC,GAAQC,GACbH,EAAOE,GAAQ9C,EAAOD,EAAO0C,EAAQK,WAElC,GAAIC,EAAQD,EAAM,CAEvBJ,EAAUK,EACV,EAAG,CACD,MAAMpC,EAASb,EAAU4C,KACV,OAAX/B,GACFP,EAASO,GAAQ,EAEpB,OAAQ+B,GAAWG,EACtB,KAAO,CACL,IAAIH,EAAUI,EAAOC,EAAQ,EAC7B,MAAME,EAAU,IAAI9I,EAAYuI,GAC1BQ,EAAW,IAAIjJ,EACrB,IAAK,IAAI2D,EAAI,EAAGA,EAAI8E,EAAS9E,IAAK,CAEhCqF,EAAQrF,IAAE,EACV,MAAMuF,EAAIJ,EAAQnF,EAClBsF,EAASzG,IAAI+F,EAAMW,GAAIA,EACzB,CAIA,IAAIC,EAAe,EACnB,IAAK,IAAIxF,EAAImF,EAAOnF,GAAKiF,EAAMjF,IAAK,CAClC,MAAM+C,EAASb,EAAUlC,GACnByF,EAAeH,EAAS5G,IAAIgG,EAAM1E,SACnB,IAAjByF,GACFD,EAAgBA,EAAeC,EAC3BA,EACD,WACHJ,EAAQI,EAAeN,GAASnF,EAChCgF,EAAOS,GAAgB1C,GACH,OAAXA,GACTP,EAASO,GAAQ,EAErB,CASA,IAHuC,KAAjCR,GAAkF,aAA7CiD,GACzCE,EAAQL,GAEHP,KAAY,GAAG,CACpBI,EAAOJ,EAAUK,EACjB,MAAMQ,EAAOd,EAAQK,GACfU,EAAWP,EAAQP,GACzBE,EAAOE,IAAuB,IAAdU,EACZxD,EAAOD,EAAOwD,GACdtD,EACAF,EACA6C,EAAOE,GACPS,EACApD,gBACEiD,IAAuD,IAARI,EAC9C,KACC,GAEV,CACF,CAIA,KAAOT,EAAQ,GACbH,IAASG,GAAS9C,EAChBF,EACAD,EAAUiD,GACVN,EAAQM,GACR5C,EAGN,CACAJ,EAAMvC,EAAIoF,CAAM,EAwBZU,EAAWlB,IACf,MAAMzE,EAASyE,EAAEzE,OACX8F,EAAS,IAAItJ,EAAYwD,GACzB+F,EAAQ,IAAIvJ,EAAYwD,GAC9B,IAEIwF,EACAZ,EACAoB,EACAC,EALAC,EAAc,EACdjG,EAAI,EAOR,UAAOwE,EAAExE,GAAgCA,KAGzC,IADA8F,EAAM,GAAK9F,IACJA,EAAID,EAAQC,IAEjB,GADA2E,EAAIH,EAAExE,IAC6B,IAA/B2E,EAEF,GADAY,EAAIO,EAAMG,GACNzB,EAAEe,GAAKZ,EACTkB,EAAO7F,GAAKuF,EACZO,IAAQG,GAAejG,MAClB,CAIL,IAHA+F,EAAK,EACLC,EAAKC,EAEEF,EAAKC,GACVT,EAAKQ,EAAKC,GAAO,EACbxB,EAAEsB,EAAMP,IAAMZ,EAChBoB,EAAKR,EAAI,EAETS,EAAKT,EAILZ,EAAIH,EAAEsB,EAAMC,MACVA,EAAK,IACPF,EAAO7F,GAAK8F,EAAMC,EAAK,IAEzBD,EAAMC,GAAM/F,EAEhB,CAMJ,IADAuF,EAAIO,EAAMG,GACHA,MAAiB,GACtBzB,EAAEe,IAAE,EACJA,EAAIM,EAAON,EACb,EAkEWW,EAAKA,CAChBhD,EACAxD,EACAnB,EACAqB,EACAsE,KACwB,CACxBxE,EAAC,EACD2D,GAAI,CAAE3D,IAAGnB,IAAGqB,IAAGsE,IAAGjB,EAAGnH,GACrBoH,OA0SWiD,EAAkC,CAC7CzG,EAAC,EACD2D,GAAI,KACJH,GAAI,MAiDAkD,EAAkBA,CAACC,EAAa9D,KACpC,KAAiC,KAAzBA,EAAc8D,EAAK3G,IAA+C,CACxE,MAAM+B,EAAMrC,GACNb,EAAEA,EAACe,EAAEA,GAAMmC,EAEjB,GADA4E,EAAK3G,EAAC,GACS,OAAX2G,EAAKzG,EAAY,CACnB,MAAM0G,EAAUD,EAAK1G,EAAEpB,EACvBa,EAAeb,EAAI+H,EAAQ/H,EAC3Ba,EAAeE,EAAIgH,EAAQhH,EAC3BmD,EAAY4D,EAAKzG,EAAY2C,GAC7BA,EAAc,EACdzC,GACF,CACA2B,EAAIlD,EAAIA,EACRkD,EAAInC,EAAIA,CACV,GAqWWiH,EAlCXlD,MAEA,IAAIJ,EAAoB,CAAEvD,EAAC,GAAc2D,GAkCxCgD,IAEC5J,GAAgB,KACd2J,EAAgBC,EAAM,EAAE,GACxB,EAtCyCnD,GAAI,MACjD,MAAO,CAAC3E,EAAYe,EAAiB,KAAM4E,IAAWzE,EAAW,GAG/D,CAEEwD,IAGA1E,EAAG,CAEDA,IAEAe,MAIJ,KAEA,KAEA4E,EACD,EAUoCsC,GCrqEcC,EAAAP,ED84ClCQ,IACjB,KACmB,iBAANA,IACTxJ,EAAayJ,UAAYD,EACzBA,EAAItJ,EAAqBE,YAEpBK,EAAcsD,KAAKyF,GAAG,ICp5CoBE,CAAA,6IAAA,IAAA,CAAA,IAAA,GAAA,KAAA,IAAA,IAAA,CAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IAAA,CAAA,GAAA,EAAA,EAAA,IAa/CC,EAAYC,GDgwDEC,CAClBC,IAGW,CACX/D,EAAGkD,EACH5H,EAAG,CACDoG,EAAGqC,EAAQC,KCvwDiCC,GAAQA,EAAKC,KDwwDzDxH,EAAGqH,EAAQC,KCxwDkDC,GDy9C/CE,EAACnE,EAAuB1E,KAAyB,CAAE0E,IAAG1E,MCz9CH6I,CAAAX,EAAA,CAChDS,EAAKC,GAAgBD,EAAKG,KAAmBH,EAAKpB,MACtDoB,EAAKI,UACKJ,EAAKK,MACHL,EAAK7J,QACN6J,EAAKM,cALGT,CAAKD,GAUzC,IAAIT,EAAoB,WAEXoB,EAASA,CAACC,EAAqBZ,KAC1CT,IAASE,EAAWmB,GD+pEAC,EAACtB,EAAY1G,KA/WfiI,EAACvB,EAAavF,KAChC,MAAMW,EAAMrC,GACNb,EAAEA,EAACe,EAAEA,GAAMmC,EACX6E,EAAUD,EAAK1G,EAAEpB,EACvBkD,EAAIlD,EAAI+H,EAAQ/H,EAChBkD,EAAInC,EAAIgH,EAAQhH,EAChB+G,EAAK3G,EAAC,GACN2G,EAAKzG,EAAIyC,EACPgE,EACAA,EAAKzG,EACLkB,EA2WI,GAxWNhB,IACA2B,EAAIlD,EAAIA,EACRkD,EAAInC,EAAIA,EACR8G,EAAgBC,EAAM,EAAE,EAgWxBuB,CACEvB,EACA1G,EAID,ECrqEDgI,CAAOtB,EAAMQ,EAASC,GAAO","x_google_ignoreList":[0]}